# Generated Output Examples

Examples of Kubernetes YAML and Docker Compose files generated by the K8s-Gen DSL.

## Kubernetes Output Examples

### 1. Basic Application with Database

**DSL Code:**
```python
from k8s_gen import App, StatefulApp, Secret

# Database
database = (StatefulApp("database")
    .image("database-server:latest")
    .port(5432)
    .storage("20Gi")
    .environment({"DATABASE_HOST": "database"}))

# Web application
blog_app = (App("blog-app")
    .image("webapp:latest")
    .port(8080)
    .connect_to([database])
    .scale(replicas=3)
    .expose(external_access=True, domain="blog.mysite.com"))

blog_app.generate().to_yaml("./k8s/")
```

**Generated Kubernetes YAML:**

```yaml
# deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: blog-app
  labels:
    app: blog-app
spec:
  replicas: 3
  selector:
    matchLabels:
      app: blog-app
  template:
    metadata:
      labels:
        app: blog-app
    spec:
      containers:
      - name: blog-app
        image: webapp:latest
        ports:
        - containerPort: 8080
          name: http
        env:
        - name: DATABASE_HOST
          value: database
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 500m
            memory: 512Mi

---
# service.yaml
apiVersion: v1
kind: Service
metadata:
  name: blog-app
  labels:
    app: blog-app
spec:
  ports:
  - port: 8080
    targetPort: 8080
    name: http
  selector:
    app: blog-app
  type: ClusterIP

---
# ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: blog-app
  annotations:
    kubernetes.io/ingress.class: ingress-controller
    cert-manager.io/cluster-issuer: letsencrypt-prod
spec:
  tls:
  - hosts:
    - blog.mysite.com
    secretName: blog-app-tls
  rules:
  - host: blog.mysite.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: blog-app
            port:
              number: 8080
```

### 2. Sidecar Container Example

**DSL Code:**
```python
from k8s_gen import App, Companion

app = (App("web-server")
    .image("web-server:latest")
    .port(8080)
    .add_companion(
        Companion("log-collector")
            .image("log-agent:latest")
            .type("sidecar")
            .mount_shared_volume("/var/log")
    ))
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: web-server
spec:
  replicas: 1
  selector:
    matchLabels:
      app: web-server
  template:
    metadata:
      labels:
        app: web-server
    spec:
      containers:
      - name: web-server
        image: web-server:latest
        ports:
        - containerPort: 8080
        volumeMounts:
        - name: shared-logs
          mountPath: /var/log
      - name: log-collector
        image: log-agent:latest
        volumeMounts:
        - name: shared-logs
          mountPath: /var/log
      volumes:
      - name: shared-logs
        emptyDir: {}
```

### 3. Persistent Storage Example

**DSL Code:**
```python
database = (StatefulApp("database")
    .image("database-server:latest")
    .port(5432)
    .storage("20Gi")
    .replicas(1)
    .environment({
        "DB_NAME": "myapp",
        "DB_USER": "admin"
    })
    .backup_schedule("0 2 * * *"))
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: database
  labels:
    app: database
spec:
  serviceName: database
  replicas: 1
  selector:
    matchLabels:
      app: database
  template:
    metadata:
      labels:
        app: database
    spec:
      containers:
      - name: database
        image: database-server:latest
        ports:
        - containerPort: 5432
          name: database
        env:
        - name: DB_NAME
          value: myapp
        - name: DB_USER
          value: admin
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: database-credentials
              key: password
        volumeMounts:
        - name: data
          mountPath: /var/lib/database/data
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 20Gi

---
apiVersion: v1
kind: Service
metadata:
  name: database
  labels:
    app: database
spec:
  ports:
  - port: 5432
    targetPort: database
  selector:
    app: database
  clusterIP: None

---
apiVersion: batch/v1
kind: CronJob
metadata:
  name: database-backup
spec:
  schedule: "0 2 * * *"
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: backup
            image: database-server:latest
            command:
            - sh
            - -c
            - "backup_tool -h database mydb > /backup/backup-$(date +%Y%m%d).sql"
            volumeMounts:
            - name: backup-storage
              mountPath: /backup
          volumes:
          - name: backup-storage
            persistentVolumeClaim:
              claimName: database-backup
          restartPolicy: OnFailure
```

### 4. Secrets Management Example

**DSL Code:**
```python
from k8s_gen import Secret

db_secret = (Secret("database-credentials")
    .add("username", "admin")
    .add("password", "super-secret-password")
    .add("connection-string", "database://admin:password@database:5432/myapp")
    .mount_path("/etc/secrets")
    .mount_as_env_vars(prefix="DB_"))

app.add_secrets([db_secret])
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: v1
kind: Secret
metadata:
  name: database-credentials
type: Opaque
data:
  username: YWRtaW4=  # base64 encoded "admin"
  password: c3VwZXItc2VjcmV0LXBhc3N3b3Jk  # base64 encoded
  connection-string: ZGF0YWJhc2U6Ly9hZG1pbjpwYXNzd29yZEBkYXRhYmFzZTo1NDMyL215YXBw
```

### 5. Advanced Job Example

**DSL Code:**
```python
from k8s_gen import Job

migration_job = (Job("db-migration")
    .image("database-server:latest")
    .command(["sh", "-c", "backup_tool -h database mydb > /backup/backup-$(date +%Y%m%d).sql"])
    .timeout("10m")
    .depends_on([database])
    .on_success(cleanup=True))
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: db-migration
spec:
  template:
    spec:
      containers:
      - name: migration
        image: database-server:latest
        command:
        - sh
        - -c
        - "backup_tool -h database mydb > /backup/backup-$(date +%Y%m%d).sql"
      restartPolicy: Never
  backoffLimit: 3
  activeDeadlineSeconds: 600  # 10m timeout
```

### 6. Advanced Ingress Example

**DSL Code:**
```python
from k8s_gen import Ingress

api_ingress = (Ingress("api-ingress")
    .host("api.mycompany.com")
    .path("/api/v1", "api-service", 8080)
    .ssl_certificate("api-tls")
    .rate_limiting(requests_per_minute=1000)
    .cors(allowed_origins=["https://myapp.com"]))
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: api-ingress
  annotations:
    kubernetes.io/ingress.class: ingress-controller
    api-ingress.ingress.kubernetes.io/rate-limit: "1000"
    api-ingress.ingress.kubernetes.io/rate-limit-window: "1m"
    api-ingress.ingress.kubernetes.io/enable-cors: "true"
    api-ingress.ingress.kubernetes.io/cors-allow-origin: "https://myapp.com"
    api-ingress.ingress.kubernetes.io/cors-allow-methods: "GET, POST, PUT, DELETE, OPTIONS"
    api-ingress.ingress.kubernetes.io/cors-allow-headers: "Authorization, Content-Type"
    api-ingress.ingress.kubernetes.io/auth-url: "http://auth-service.default.svc.cluster.local/auth"
    api-ingress.ingress.kubernetes.io/configuration-snippet: |
      more_set_headers "X-Request-ID $request_id";
      access_log /var/log/ingress/api-access.log main;
spec:
  tls:
  - hosts:
    - api.mycompany.com
    secretName: api-tls
  rules:
  - host: api.mycompany.com
    http:
      paths:
      - path: /api/v1
        pathType: Prefix
        backend:
          service:
            name: api-service
            port:
              number: 8080
```

### 7. Multi-Service Application Example

**DSL Code:**
```python
from k8s_gen import AppGroup

microservices = AppGroup("ecommerce")

database = StatefulApp("database").image("database-server:latest").storage("100Gi")
cache = StatefulApp("cache").image("cache-server:latest").storage("10Gi")

user_service = App("users").image("myorg/users:v1.0").port(8080).connect_to([database])
product_service = App("products").image("myorg/products:v1.0").port(8081).connect_to([database])

microservices.add_services([database, cache, user_service, product_service])
```

**Generated Kubernetes YAML:**

```yaml
apiVersion: v1
kind: Namespace
metadata:
  name: ecommerce

---
# Database StatefulSet, Service, and PVC
# ... (database resources as shown above)

---
# Cache StatefulSet and Service
# ... (cache resources)

---
# User Service Deployment and Service
apiVersion: apps/v1
kind: Deployment
metadata:
  name: users
  namespace: ecommerce
spec:
  replicas: 3
  selector:
    matchLabels:
      app: users
  template:
    metadata:
      labels:
        app: users
    spec:
      containers:
      - name: users
        image: myorg/users:v1.0
        ports:
        - containerPort: 8080
        env:
        - name: DATABASE_HOST
          value: database.ecommerce.svc.cluster.local

---
# Similar structure for Product Service
```

## ConfigMap Examples

### Simple Configuration

**DSL Code:**
```python
app_config = (ConfigMap("app-config")
    .add("database_url", "database://localhost:5432/myapp")
    .add("cache_ttl", "3600")
    .add("debug_mode", "false"))
```

**Generated ConfigMap:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
data:
  database_url: "database://localhost:5432/myapp"
  cache_ttl: "3600"
  debug_mode: "false"
```

### File-based Configuration

**DSL Code:**
```python
file_config = (ConfigMap("file-config")
    .from_file("web-server.conf", "./config/web-server.conf")
    .from_directory("./config/", pattern="*.conf"))
```

**Generated ConfigMap:**

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: file-config
data:
  web-server.conf: |
    server {
        listen 80;
        server_name localhost;
        root /usr/share/web-server/html;
        index index.html index.htm;
    }
  
  database.conf: |
    [database]
    host = localhost
    port = 5432
    name = myapp
```

### Complex Configuration Example

**DSL Code:**
```python
wp_config = ConfigMap("webapp-config").add("DATABASE_HOST", "database")

database = (StatefulApp("database")
    .image("database-server:latest")
    .port(3306)
    .storage("20Gi")
    .environment({"DB_NAME": "blog", "DB_ROOT_PASSWORD": "secret"}))

blog_app = (App("blog-app")
    .image("webapp:latest")
    .port(8080)
    .add_config([wp_config])
    .connect_to([database])
    .scale(replicas=3)
    .expose(external_access=True))
```

## Docker Compose Output Examples

### 1. Single Application with Database

**Generated Docker Compose:**
```yaml
# docker-compose.yml
version: '3.8'

services:
  database:
    image: database-server:latest
    container_name: database
    restart: unless-stopped
    ports:
      - "3306:3306"
    environment:
      DB_NAME: blog
      DB_ROOT_PASSWORD: secret
    volumes:
      - database_data:/var/lib/database
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "database-admin", "ping", "-h", "localhost"]
      interval: 30s
      timeout: 10s
      retries: 5

  blog-app:
    image: webapp:latest
    container_name: blog-app
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      DATABASE_HOST: database
    depends_on:
      database:
        condition: service_healthy
    networks:
      - app-network
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  database_data:

networks:
  app-network:
    driver: bridge
```

**Docker Compose Override for Development:**
```yaml
# docker-compose.override.yml (for development)
version: '3.8'

services:
  database:
    ports:
      - "3306:3306"  # Expose database port for debugging
    volumes:
      - ./database-dev-data:/var/lib/database  # Use local directory

  blog-app:
    ports:
      - "8080:8080"  # Different port for development
    volumes:
      - ./app-content:/var/www/html/content  # Mount source code
    environment:
      APP_DEBUG: 1
    deploy:
      replicas: 1  # Single instance for development
```

**Docker Compose for Production:**
```yaml
# docker-compose.prod.yml
version: '3.8'

services:
  database:
    deploy:
      resources:
        limits:
          memory: 1G
          cpus: '0.5'
        reservations:
          memory: 512M
          cpus: '0.25'

  blog-app:
    deploy:
      replicas: 3
      resources:
        limits:
          memory: 512M
          cpus: '0.5'
        reservations:
          memory: 256M
          cpus: '0.25'
      restart_policy:
        condition: on-failure
        delay: 5s
        max_attempts: 5
    environment:
      APP_DEBUG: 0
```

### 2. Microservices Docker Compose Output

**DSL Code:**
```python
microservices = AppGroup("ecommerce")

# Stateful services
database = StatefulApp("database").image("database-server:latest").storage("20Gi")
cache = StatefulApp("cache").image("cache-server:latest").storage("5Gi")

# Microservices
user_service = (App("user-service")
    .image("mycompany/users:v1.0.0")
    .port(8080)
    .connect_to([database, cache]))

product_service = (App("product-service")
    .image("mycompany/products:v1.0.0")
    .port(8081)
    .connect_to([database]))

api_gateway = (App("api-gateway")
    .image("web-server:latest")
    .port(80)
    .depends_on([user_service, product_service])
    .expose(external_access=True))

microservices.add_services([database, cache, user_service, product_service, api_gateway])
microservices.generate().to_docker_compose("./docker-compose.yml")
```

**Generated Docker Compose:**

```yaml
# docker-compose.yml
version: '3.8'

services:
  database:
    image: database-server:latest
    container_name: ecommerce-database
    restart: unless-stopped
    ports:
      - "5432:5432"
    environment:
      DB_NAME: ecommerce
      DB_USER: admin
      DB_PASSWORD: ${DB_PASSWORD:-secret}
    volumes:
      - database_data:/var/lib/database/data
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD-SHELL", "database-ready -U admin -d ecommerce"]
      interval: 30s
      timeout: 10s
      retries: 5

  cache:
    image: cache-server:latest
    container_name: ecommerce-cache
    restart: unless-stopped
    ports:
      - "6379:6379"
    volumes:
      - cache_data:/data
    networks:
      - ecommerce-network
    healthcheck:
      test: ["CMD", "cache-cli", "ping"]
      interval: 30s
      timeout: 10s
      retries: 5

  user-service:
    image: mycompany/users:v1.0.0
    container_name: ecommerce-user-service
    restart: unless-stopped
    ports:
      - "8080:8080"
    environment:
      DB_HOST: database
      CACHE_HOST: cache
      SPRING_PROFILES_ACTIVE: docker
    networks:
      - ecommerce-network
    depends_on:
      database:
        condition: service_healthy
      cache:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  product-service:
    image: mycompany/products:v1.0.0
    container_name: ecommerce-product-service
    restart: unless-stopped
    ports:
      - "8081:8081"
    environment:
      DB_HOST: database
      SPRING_PROFILES_ACTIVE: docker
    networks:
      - ecommerce-network
    depends_on:
      database:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8081/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  api-gateway:
    image: web-server:latest
    container_name: ecommerce-api-gateway
    restart: unless-stopped
    ports:
      - "80:80"
    networks:
      - ecommerce-network
    depends_on:
      user-service:
        condition: service_healthy
      product-service:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:80/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  database_data:
  cache_data:

networks:
  ecommerce-network:
    driver: bridge
```

## Helm Chart Output

### Chart Structure

```
charts/
└── my-app/
    ├── Chart.yaml
    ├── values.yaml
    ├── templates/
    │   ├── deployment.yaml
    │   ├── service.yaml
    │   ├── ingress.yaml
    │   ├── configmap.yaml
    │   ├── secret.yaml
    │   └── NOTES.txt
    └── charts/  # Sub-charts for dependencies
```

### Generated values.yaml

```yaml
# values.yaml
image:
  repository: webapp
  tag: latest
  pullPolicy: IfNotPresent

replicaCount: 3

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: true
  host: blog.mysite.com
  tls:
    enabled: true
    secretName: blog-app-tls

resources:
  limits:
    cpu: 500m
    memory: 512Mi
  requests:
    cpu: 100m
    memory: 128Mi

autoscaling:
  enabled: true
  minReplicas: 2
  maxReplicas: 10
  targetCPUUtilizationPercentage: 70

database:
  enabled: true
  image: database-server:latest
  storage: 20Gi
```

## Kustomize Output

### Base Configuration

```yaml
# base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- deployment.yaml
- service.yaml
- configmap.yaml

commonLabels:
  app: my-app
  version: v1.0.0

images:
- name: webapp
  newTag: latest
```

### Environment Overlays

```yaml
# overlays/production/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
- ../../base
- ingress.yaml

patchesStrategicMerge:
- deployment-patch.yaml

replicas:
- name: my-app
  count: 5

images:
- name: webapp
  newTag: v1.2.3
```

## DSL Concept to Resource Mapping

| DSL Concept | Kubernetes Output | Docker Compose Output |
|-------------|-------------------|------------------------|
| `App()` | Deployment + Service | service definition |
| `StatefulApp()` | StatefulSet + Service + PVC | service with volume |
| `.port(8080)` | Service port + container port | ports mapping |
| `.replicas(3)` | Deployment replicas | deploy.replicas |
| `.expose(external_access=True)` | LoadBalancer Service + Ingress | Published ports |
| `.add_storage(type="persistent")` | PersistentVolumeClaim | Named volumes |
| `.add_storage(type="config")` | ConfigMap | File mounts + environment |
| `.add_storage(type="secret")` | Secret | Environment variables (secrets) |
| `.add_companion(type="sidecar")` | Additional container in Pod | Additional service in compose |
| `.add_companion(type="init")` | InitContainer in Pod | depends_on with init service |
| `.health()` | Liveness/Readiness Probes | healthcheck configuration |
| `.lifecycle()` | Lifecycle hooks (preStop, postStart) | restart_policy + stop_signal |
| `.security()` | SecurityContext + PodSecurityPolicy | user, security_opt settings |
| `.observability()` | ServiceMonitor + PrometheusRule + ConfigMap | logging and monitoring configs |
| `.deployment_strategy()` | Deployment strategy + Argo Rollouts | Deploy configuration |
| `.external_services()` | ExternalName Service + ConfigMap | external_links and networks |
| `AppGroup()` | Namespace + multiple Deployments/StatefulSets | Multiple services + networks |
| `.connect_to()` | Service references + environment variables | depends_on + networks + env vars |
| `.service_mesh()` | Service + VirtualService + DestinationRule | networks + external networks | 